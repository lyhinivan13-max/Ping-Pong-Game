<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Ping Pong — Mobile-ready (virtual buttons + fullscreen + mobile optim.)</title>
<style>
  :root{
    --bg: #0b0f1a;
    --panel: rgba(255,255,255,0.06);
    --text: #e6f7ff;
    --muted: rgba(230,247,255,0.6);
    --accent: #00f0ff;
    --accent-2: #7b61ff;
    --glow: 0 0 12px rgba(0,240,255,0.18);
  }

  /* light mode overrides */
  .light-mode {
    --bg: linear-gradient(180deg,#f6fbff,#e9f2ff);
    --panel: rgba(11,15,26,0.04);
    --text: #071124;
    --muted: rgba(7,17,36,0.5);
    --accent: #0077b6;
    --accent-2: #5c4bd6;
    --glow: 0 0 10px rgba(5,80,130,0.06);
    color-scheme: light;
  }

  /* Retro */
  .theme-retro { --bg: linear-gradient(180deg,#0b1e2a,#071017); --accent:#ffd166; --accent-2:#06d6a0; --panel: rgba(0,0,0,0.25); --text:#fff3d9; --muted:rgba(255,243,217,0.6); --glow: 0 0 18px rgba(255,209,102,0.12); }
  .theme-dark { --bg: linear-gradient(180deg,#060606,#0f1216); --accent:#4dd0e1; --accent-2:#90caf9; --panel: rgba(255,255,255,0.04); --text:#cfeff6; --muted:rgba(207,239,246,0.6); --glow: 0 0 10px rgba(77,208,225,0.12); }
  .theme-forest { --bg: linear-gradient(180deg,#021305,#052014); --accent:#8df57e; --accent-2:#32a852; --panel: rgba(255,255,255,0.03); --text:#e6ffe9; --muted:rgba(230,255,233,0.6); --glow: 0 0 14px rgba(141,245,126,0.08); }

  body,html{
    height:100%;
    margin:0;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: var(--bg);
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .app {
    width:min(1100px,95vw);
    display:grid;
    grid-template-columns: 1fr 380px;
    gap:20px;
    align-items:start;
    padding:28px;
  }

  .game-panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:14px;
    padding:18px;
    box-shadow: var(--glow), 0 6px 20px rgba(0,0,0,0.5);
    position:relative;
    overflow:hidden;
  }

  canvas{
    width:100%;
    height:calc(100vh - 200px);
    display:block;
    border-radius:10px;
    background: radial-gradient(circle at 10% 10%, rgba(255,255,255,0.02), transparent 10%),
                radial-gradient(circle at 90% 90%, rgba(0,0,0,0.04), transparent 20%);
    box-shadow: inset 0 0 40px rgba(0,0,0,0.25);
  }

  .hud{
    position:absolute;
    top:12px;
    left:12px;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .score{
    font-weight:700;
    font-size:28px;
    padding:8px 12px;
    background:var(--panel);
    border-radius:8px;
    color:var(--text);
    box-shadow: var(--glow);
    min-width:64px;
    text-align:center;
  }
  .center-hud{
    position:absolute;
    top:12px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:8px;
    align-items:center;
  }
  .label{
    font-size:12px;
    color:var(--muted);
    padding:6px 10px;
    background:transparent;
    border-radius:8px;
  }

  .canvas-divider{
    position:absolute;
    width:4px;
    left:50%;
    top:60px;
    bottom:16px;
    transform:translateX(-50%);
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    pointer-events:none;
  }
  .dot{
    width:6px;
    height:14px;
    border-radius:3px;
    background:linear-gradient(180deg,var(--accent),var(--accent-2));
    opacity:0.55;
    box-shadow: 0 0 8px rgba(255,255,255,0.04), var(--glow);
  }

  .controls{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04));
    border-radius:14px;
    padding:16px;
    height:fit-content;
  }
  .controls h2{
    margin:0 0 6px 0;
    font-size:18px;
    letter-spacing:0.2px;
  }
  .row{ display:flex; gap:8px; margin:10px 0; align-items:center; flex-wrap:wrap; }
  .btn{
    border: none;
    padding:10px 12px;
    border-radius:10px;
    background:var(--panel);
    color:var(--text);
    cursor:pointer;
    font-weight:600;
    box-shadow: var(--glow);
  }
  .btn.primary{
    background: linear-gradient(90deg,var(--accent),var(--accent-2));
    color:#0b0f1a;
  }
  .select {
    padding:8px 10px;
    border-radius:10px;
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--text);
  }
  .small{ font-size:13px; padding:6px 8px; }
  .muted{ color:var(--muted); font-size:13px; }

  .leaderboard{
    margin-top:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(0,0,0,0.03));
    padding:10px;
    border-radius:10px;
    max-height:300px;
    overflow:auto;
  }
  .lb-row{ display:flex; justify-content:space-between; gap:6px; padding:8px; border-radius:8px; align-items:center; }
  .lb-rank{ font-weight:700; width:28px; text-align:center; }
  .lb-name{ flex:1; padding-left:8px; color:var(--text); }
  .lb-meta{ font-size:12px; color:var(--muted); width:140px; text-align:right; }

  .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,0.45); display:none; align-items:center; justify-content:center; z-index:40; }
  .modal{ background:var(--bg); padding:16px; border-radius:10px; width:320px; box-shadow:var(--glow); border:1px solid rgba(255,255,255,0.03); }
  .modal h3{ margin:0 0 8px 0; }
  .modal .input{ width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:var(--text); margin-bottom:8px; }

  /* touch overlay (virtual buttons) */
  .touch-overlay { position:absolute; left:8px; right:8px; bottom:8px; pointer-events:none; z-index:30; }
  .touch-side { position:absolute; bottom:12px; display:flex; flex-direction:column; gap:8px; pointer-events:auto; }
  .touch-left { left:12px; }
  .touch-right { right:12px; }
  .touch-overlay .btn { font-size:15px; width:56px; height:44px; border-radius:8px; opacity:0.95; }

  /* landscape hint */
  .landscape-hint { position:absolute; left:50%; transform:translateX(-50%); top:50%; translate: -50% 0; background:var(--panel); padding:10px 14px; border-radius:12px; color:var(--muted); display:none; z-index:50; }

  @media (max-width:900px){
    .app{ grid-template-columns: 1fr; padding:14px; gap:12px; }
    canvas{ height:54vh; }
    .touch-overlay { display:block; }
    .landscape-hint { display:block; }
  }
</style>
</head>
<body class="theme-neon" data-theme="neon">
<div class="app">
  <div class="game-panel">
    <div class="hud">
      <div class="score" id="scoreLeft">0</div>
      <div class="label muted">—</div>
      <div class="score" id="scoreRight">0</div>
    </div>
    <div class="center-hud">
      <div class="label muted">Клавиши: W/S — левый, ↑/↓ — правый</div>
    </div>

    <div class="canvas-divider" aria-hidden="true">
      <div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <canvas id="pong"></canvas>

    <div style="position:absolute; right:12px; bottom:12px;">
      <button class="btn small" id="serveBtn">Старт / Подача</button>
      <button class="btn small" id="resetBtn">Сброс счета</button>
    </div>

    <!-- touch overlay: virtual controls + fullscreen -->
    <div class="touch-overlay" id="touchOverlay" aria-hidden="false">
      <div class="touch-side touch-left" id="touchLeft">
        <button class="btn small" id="leftUp">▲</button>
        <button class="btn small" id="leftDown">▼</button>
      </div>
      <div class="touch-side touch-right" id="touchRight" style="align-items:flex-end;">
        <button class="btn small" id="rightUp">▲</button>
        <button class="btn small" id="rightDown">▼</button>
      </div>
      <div style="position:absolute; right:12px; top:12px; pointer-events:auto;">
        <button class="btn small" id="fullscreenBtn">⤢</button>
      </div>
    </div>

    <div class="landscape-hint" id="landscapeHint">Переверните телефон в ландшафт для лучшего опыта</div>
  </div>

  <div class="controls" role="region" aria-label="Controls">
    <h2>Настройки</h2>

    <div class="row">
      <label class="muted">Сложность</label>
      <select id="difficulty" class="select">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>

    <div class="row">
      <label class="muted">Тема</label>
      <select id="theme" class="select">
        <option value="neon">Neon</option>
        <option value="retro">Retro</option>
        <option value="dark">Dark</option>
        <option value="forest">Forest</option>
      </select>
    </div>

    <div class="row">
      <label class="muted">Светлая тема</label>
      <button id="lightToggle" class="btn">Переключить</button>
    </div>

    <div class="row">
      <label class="muted">Режим</label>
      <select id="mode" class="select">
        <option value="cpu" selected>Против компьютера</option>
        <option value="local">2 игрока (локально)</option>
      </select>
    </div>

    <div class="row">
      <label class="muted">Громкость</label>
      <input id="volume" type="range" min="0" max="1" step="0.05" value="0.35" />
    </div>

    <div class="row">
      <button id="saveScoreBtn" class="btn primary">Добавить текущий счёт в таблицу</button>
      <button id="clearLbBtn" class="btn">Очистить таблицу</button>
    </div>

    <div class="row">
      <label class="muted">Частицы при ударах</label>
      <button id="particlesToggle" class="btn">Вкл/Выкл</button>
    </div>

    <div class="leaderboard" id="leaderboard"></div>

    <div class="footer-note muted" style="margin-top:12px;">Таблица рекордов хранится в вашем браузере (localStorage).</div>
  </div>
</div>

<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal" role="dialog" aria-modal="true">
    <h3>Сохранить рекорд</h3>
    <div class="muted" id="modalInfo">Кому: —, Очки: —</div>
    <input id="playerName" class="input" maxlength="20" placeholder="Введите имя (необязательно)" />
    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="modalCancel" class="btn">Отмена</button>
      <button id="modalSave" class="btn primary">Сохранить</button>
    </div>
  </div>
</div>

<script>
/* Полная версия Pong + mobile fixes:
   - virtual on-screen buttons
   - fullscreen toggle
   - auto-disable particles on small touch devices for perf
   - rest (leaderboard, light theme) preserved
*/

(() => {
  // Elements
  const canvas = document.getElementById('pong');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreLeftEl = document.getElementById('scoreLeft');
  const scoreRightEl = document.getElementById('scoreRight');
  const difficultySel = document.getElementById('difficulty');
  const themeSel = document.getElementById('theme');
  const modeSel = document.getElementById('mode');
  const serveBtn = document.getElementById('serveBtn');
  const resetBtn = document.getElementById('resetBtn');
  const particlesToggle = document.getElementById('particlesToggle');
  const volumeRange = document.getElementById('volume');
  const lightToggle = document.getElementById('lightToggle');
  const saveScoreBtn = document.getElementById('saveScoreBtn');
  const clearLbBtn = document.getElementById('clearLbBtn');
  const leaderboardEl = document.getElementById('leaderboard');
  const modalBackdrop = document.getElementById('modalBackdrop');
  const modalInfo = document.getElementById('modalInfo');
  const modalSaveBtn = document.getElementById('modalSave');
  const modalCancelBtn = document.getElementById('modalCancel');
  const playerNameInput = document.getElementById('playerName');
  const leftUp = document.getElementById('leftUp');
  const leftDown = document.getElementById('leftDown');
  const rightUp = document.getElementById('rightUp');
  const rightDown = document.getElementById('rightDown');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const landscapeHint = document.getElementById('landscapeHint');

  // localStorage keys
  const KEY_THEME = 'pongTheme_v1';
  const KEY_DIFF = 'pongDiff_v1';
  const KEY_MODE = 'pongMode_v1';
  const KEY_VOLUME = 'pongVol_v1';
  const KEY_PARTS = 'pongParts_v1';
  const KEY_LIGHT = 'pongLight_v1';
  const KEY_LEADER = 'pongLeaderboard_v1';

  // Detect mobile-ish device
  const isTouch = ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0) || ('ontouchstart' in window);
  const isNarrow = window.matchMedia && window.matchMedia('(max-width:900px)').matches;
  const isMobileLike = isTouch || isNarrow;

  // initial settings from storage
  const savedTheme = localStorage.getItem(KEY_THEME) || 'neon';
  const savedDiff = localStorage.getItem(KEY_DIFF) || 'medium';
  const savedMode = localStorage.getItem(KEY_MODE) || 'cpu';
  const savedVol = parseFloat(localStorage.getItem(KEY_VOLUME) ?? volumeRange.value);
  const savedParts = (localStorage.getItem(KEY_PARTS) ?? 'true') === 'true';
  const savedLight = (localStorage.getItem(KEY_LIGHT) ?? 'false') === 'true';

  themeSel.value = savedTheme;
  difficultySel.value = savedDiff;
  modeSel.value = savedMode;
  volumeRange.value = savedVol;

  if(savedLight) document.body.classList.add('light-mode');

  // Theme application
  function applyTheme(key){
    document.body.classList.remove('theme-neon','theme-retro','theme-dark','theme-forest');
    if(key === 'neon'){ document.body.classList.add('theme-neon'); document.body.style.setProperty('--bg','linear-gradient(180deg,#0b0f1a,#071220)'); }
    if(key === 'retro'){ document.body.classList.add('theme-retro'); }
    if(key === 'dark'){ document.body.classList.add('theme-dark'); }
    if(key === 'forest'){ document.body.classList.add('theme-forest'); }
    localStorage.setItem(KEY_THEME, key);
  }
  applyTheme(savedTheme);

  // canvas sizing
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(640, Math.floor(rect.width * devicePixelRatio));
    canvas.height = Math.max(360, Math.floor(rect.height * devicePixelRatio));
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  setTimeout(resizeCanvas, 60);

  // Game state
  let state = {
    leftScore:0,
    rightScore:0,
    playing:false,
    ball: { x:0, y:0, r:8, vx:0, vy:0, speed:6 },
    paddleLeft: { x:20, y:0, w:10, h:110, vy:0 },
    paddleRight: { x:0, y:0, w:10, h:110, vy:0 },
    keys:{},
    difficulty: difficultySel.value,
    mode: modeSel.value,
    aiDebug:false,
    volume: parseFloat(volumeRange.value),
    speedBoost: 0,
    particles: [],
    particlesEnabled: savedParts
  };

  // If device is mobile-like, default to disabling particles for perf
  if(isMobileLike && savedParts === undefined){
    state.particlesEnabled = false;
  }
  // If explicitly saved, respect savedParts
  state.particlesEnabled = savedParts;

  function difficultyConfig(diff = state.difficulty){
    if(diff === 'easy') return { ballSpeed:4.5, paddleH:140, aiSpeed:3 };
    if(diff === 'medium') return { ballSpeed:6, paddleH:110, aiSpeed:4.5 };
    if(diff === 'hard') return { ballSpeed:8, paddleH:90, aiSpeed:6.5 };
    return { ballSpeed:6, paddleH:110, aiSpeed:4.5 };
  }
  function applyDifficulty(diff){
    state.difficulty = diff;
    const cfg = difficultyConfig(diff);
    state.ball.speed = cfg.ballSpeed;
    state.paddleLeft.h = cfg.paddleH;
    state.paddleRight.h = cfg.paddleH;
    localStorage.setItem(KEY_DIFF, diff);
  }
  applyDifficulty(savedDiff);

  // positions
  function resetPositions(){
    const width = W();
    const height = H();
    state.ball.x = width/2;
    state.ball.y = height/2;
    state.ball.r = Math.max(6, Math.min(12, Math.round(width/80)));
    state.paddleLeft.h = difficultyConfig().paddleH;
    state.paddleRight.h = difficultyConfig().paddleH;
    state.paddleLeft.y = height/2 - state.paddleLeft.h/2;
    state.paddleRight.x = width - 20 - state.paddleRight.w;
    state.paddleRight.y = height/2 - state.paddleRight.h/2;
  }

  // audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new AudioCtx();
  }
  function playBeep(freq=440, t=0.06, vol=0.25){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.value = vol * state.volume;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + t);
  }

  // particles
  function spawnParticles(x,y,color){
    if(!state.particlesEnabled) return;
    for(let i=0;i<12;i++){
      state.particles.push({
        x,y,
        vx:(Math.random()-0.5)*6,
        vy:(Math.random()-0.8)*4 - 1,
        life:40 + Math.random()*30,
        color,
        size:1 + Math.random()*3
      });
    }
  }
  function updateParticles(){
    for(let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.12;
      p.life -= 1;
      if(p.life <= 0) state.particles.splice(i,1);
    }
  }

  // input
  window.addEventListener('keydown', e => {
    state.keys[e.key.toLowerCase()] = true;
    if(!audioCtx) { try{ ensureAudio(); }catch(e){} }
    if(e.key === ' ') { serve(); e.preventDefault(); }
  });
  window.addEventListener('keyup', e => { state.keys[e.key.toLowerCase()] = false; });

  // touch drag
  let touchId = null;
  canvas.addEventListener('touchstart', e => {
    const t = e.changedTouches[0];
    touchId = t.identifier;
    handleTouchMove(t);
    e.preventDefault();
  }, { passive:false });
  canvas.addEventListener('touchmove', e => {
    for(const t of e.changedTouches) if(t.identifier === touchId) handleTouchMove(t);
    e.preventDefault();
  }, { passive:false });
  canvas.addEventListener('touchend', e => { touchId = null; });

  function handleTouchMove(t){
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    if(x < rect.width/2) state.paddleLeft.y = y - state.paddleLeft.h/2;
    else if(state.mode === 'local') state.paddleRight.y = y - state.paddleRight.h/2;
  }

  // UI handlers
  difficultySel.addEventListener('change', () => applyDifficulty(difficultySel.value));
  themeSel.addEventListener('change', () => applyTheme(themeSel.value));
  modeSel.addEventListener('change', () => { state.mode = modeSel.value; localStorage.setItem(KEY_MODE, state.mode); });
  volumeRange.addEventListener('input', () => { state.volume = parseFloat(volumeRange.value); localStorage.setItem(KEY_VOLUME, state.volume); });
  particlesToggle.addEventListener('click', () => {
    state.particlesEnabled = !state.particlesEnabled;
    localStorage.setItem(KEY_PARTS, state.particlesEnabled);
    particlesToggle.textContent = state.particlesEnabled ? 'Частицы: Вкл' : 'Частицы: Выкл';
  });
  lightToggle.addEventListener('click', () => {
    document.body.classList.toggle('light-mode');
    localStorage.setItem(KEY_LIGHT, document.body.classList.contains('light-mode'));
  });

  serveBtn.addEventListener('click', serve);
  resetBtn.addEventListener('click', () => { state.leftScore = 0; state.rightScore = 0; updateScoreUI(); resetPositions(); });

  // Leaderboard helpers
  function loadLeaderboard(){ try{ return JSON.parse(localStorage.getItem(KEY_LEADER) || '[]'); }catch(e){ return []; } }
  function saveLeaderboard(arr){ localStorage.setItem(KEY_LEADER, JSON.stringify(arr.slice(0,20))); renderLeaderboard(); }
  function renderLeaderboard(){
    const arr = loadLeaderboard();
    leaderboardEl.innerHTML = '';
    if(arr.length === 0){ leaderboardEl.innerHTML = '<div class="muted">Еще нет рекордов — будь первым!</div>'; return; }
    arr.slice(0,20).forEach((it, idx) => {
      const row = document.createElement('div');
      row.className = 'lb-row';
      row.innerHTML = `<div class="lb-rank">${idx+1}</div>
        <div class="lb-name">${escapeHtml(it.name || 'Аноним')}</div>
        <div class="lb-meta">${it.score} • ${escapeHtml(it.diff)} • ${escapeHtml(it.mode)} • ${new Date(it.date).toLocaleDateString()}</div>`;
      leaderboardEl.appendChild(row);
    });
  }
  renderLeaderboard();

  clearLbBtn.addEventListener('click', () => {
    if(confirm('Очистить таблицу рекордов?')) saveLeaderboard([]);
  });

  saveScoreBtn.addEventListener('click', () => {
    const who = state.leftScore >= state.rightScore ? 'Left' : 'Right';
    openSaveModal(who === 'Left' ? 'Левый игрок' : 'Правый игрок', Math.max(state.leftScore, state.rightScore), who);
  });

  function checkAutoSave(side, score){
    const lb = loadLeaderboard();
    if(lb.length < 10 || score > (lb[lb.length-1]?.score ?? -1)){
      openSaveModal(side === 'left' ? 'Левый игрок' : 'Правый игрок', score, side === 'left' ? 'Left' : 'Right');
    }
  }

  // modal
  let modalContext = null;
  function openSaveModal(nameHint, score, sideKey){
    modalContext = { nameHint, score, sideKey };
    modalInfo.textContent = `Кому: ${nameHint}, Очки: ${score}`;
    playerNameInput.value = '';
    modalBackdrop.style.display = 'flex';
    playerNameInput.focus();
  }
  function closeModal(){ modalBackdrop.style.display = 'none'; modalContext = null; }
  modalCancelBtn.addEventListener('click', closeModal);
  modalBackdrop.addEventListener('click', (e) => { if(e.target === modalBackdrop) closeModal(); });
  modalSaveBtn.addEventListener('click', () => {
    if(!modalContext) return;
    const name = playerNameInput.value.trim() || 'Аноним';
    const lb = loadLeaderboard();
    lb.push({ name, score: modalContext.score, date: new Date().toISOString(), diff: state.difficulty, mode: state.mode });
    lb.sort((a,b) => b.score - a.score || (a.date < b.date ? -1 : 1));
    saveLeaderboard(lb.slice(0,20));
    closeModal();
  });

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }

  // Canvas helpers
  function W(){ return canvas.clientWidth; }
  function H(){ return canvas.clientHeight; }

  // Serve
  function serve(side = null){
    try{ ensureAudio(); }catch(e){}
    if(state.playing === false) state.playing = true;
    const cfg = difficultyConfig(state.difficulty);
    const dir = side === 'left' ? -1 : (side === 'right' ? 1 : (Math.random()<0.5 ? 1 : -1));
    const angle = (Math.random()*0.7 - 0.35);
    state.ball.x = W()/2;
    state.ball.y = H()/2;
    const speed = cfg.ballSpeed + parseFloat(state.speedBoost || 0);
    state.ball.vx = dir * speed * (0.9 + Math.random()*0.4);
    state.ball.vy = angle * speed * 1.5;
  }

  // collisions
  function rectCircleCollide(rx, ry, rw, rh, cx, cy, cr){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = nx - cx, dy = ny - cy;
    return (dx*dx + dy*dy) <= (cr*cr);
  }

  // AI
  function aiStep(){
    if(state.mode !== 'cpu') return;
    const cfg = difficultyConfig(state.difficulty);
    const targetY = state.ball.y - state.paddleRight.h/2;
    const diff = targetY - state.paddleRight.y;
    let speed = cfg.aiSpeed;
    if(state.difficulty === 'easy') speed *= 0.75;
    if(state.difficulty === 'hard') speed *= 1.15;
    const move = Math.max(-speed, Math.min(speed, diff * 0.12));
    state.paddleRight.y += move;
  }

  // draw
  function draw() {
    try { ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg'); } catch(e) { ctx.fillStyle = '#071220'; }
    ctx.fillRect(0,0,W(),H());

    // middle dashed line
    const midx = W()/2;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    const dashH = 18, gap = 12;
    for(let y=40;y<H()-30;y+=dashH+gap) ctx.fillRect(midx-2, y, 4, dashH);

    // paddles
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--accent') || '#00f0ff';
    roundRect(ctx, state.paddleLeft.x, state.paddleLeft.y, state.paddleLeft.w, state.paddleLeft.h, 6);
    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--accent-2') || '#7b61ff';
    roundRect(ctx, state.paddleRight.x, state.paddleRight.y, state.paddleRight.w, state.paddleRight.h, 6);

    // ball
    ctx.beginPath();
    const grad = ctx.createRadialGradient(state.ball.x-2, state.ball.y-2, 2, state.ball.x, state.ball.y, state.ball.r*2);
    grad.addColorStop(0, 'white'); grad.addColorStop(0.6, 'rgba(255,255,255,0.85)'); grad.addColorStop(1, 'rgba(255,255,255,0.05)');
    ctx.fillStyle = grad;
    ctx.arc(state.ball.x, state.ball.y, state.ball.r, 0, Math.PI*2);
    ctx.fill();

    // particles
    for(const p of state.particles){
      ctx.globalAlpha = Math.max(0, p.life/60);
      ctx.fillStyle = p.color || getComputedStyle(document.body).getPropertyValue('--accent');
      ctx.fillRect(p.x, p.y, p.size, p.size);
      ctx.globalAlpha = 1;
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // main loop
  let lastTime = performance.now();
  function loop(now){
    const dt = Math.min(32, now - lastTime)/16.666;
    lastTime = now;

    resizeCanvasIfNeeded();

    // show landscape hint on narrow touch devices
    if(isMobileLike && window.innerWidth < window.innerHeight) {
      landscapeHint.style.display = 'block';
    } else {
      landscapeHint.style.display = 'none';
    }

    const speed = 8 + (state.speedBoost*1.5);
    if(state.keys['w']) state.paddleLeft.y -= speed * dt;
    if(state.keys['s']) state.paddleLeft.y += speed * dt;
    if(state.mode === 'local'){
      if(state.keys['arrowup']) state.paddleRight.y -= speed * dt;
      if(state.keys['arrowdown']) state.paddleRight.y += speed * dt;
    }

    aiStep();

    // ball move
    state.ball.x += state.ball.vx * dt;
    state.ball.y += state.ball.vy * dt;

    // top/bottom
    if(state.ball.y - state.ball.r < 0){
      state.ball.y = state.ball.r;
      state.ball.vy = -state.ball.vy;
      playBeep(420,0.03,0.08);
    } else if(state.ball.y + state.ball.r > H()){
      state.ball.y = H() - state.ball.r;
      state.ball.vy = -state.ball.vy;
      playBeep(420,0.03,0.08);
    }

    // clamp paddles
    state.paddleLeft.y = clamp(state.paddleLeft.y, 10, H() - state.paddleLeft.h - 10);
    state.paddleRight.y = clamp(state.paddleRight.y, 10, H() - state.paddleRight.h - 10);

    // collisions
    const leftRect = { x: state.paddleLeft.x, y: state.paddleLeft.y, w: state.paddleLeft.w, h: state.paddleLeft.h };
    const rightRect = { x: state.paddleRight.x, y: state.paddleRight.y, w: state.paddleRight.w, h: state.paddleRight.h };

    if(rectCircleCollide(leftRect.x, leftRect.y, leftRect.w, leftRect.h, state.ball.x, state.ball.y, state.ball.r)){
      state.ball.x = leftRect.x + leftRect.w + state.ball.r + 0.5;
      const rel = (state.ball.y - (leftRect.y + leftRect.h/2)) / (leftRect.h/2);
      const speedNow = Math.hypot(state.ball.vx, state.ball.vy);
      const angle = rel * (Math.PI/3);
      state.ball.vx = Math.cos(angle) * Math.abs(speedNow);
      state.ball.vy = Math.sin(angle) * Math.abs(speedNow);
      if(state.ball.vx < 0) state.ball.vx = Math.abs(state.ball.vx);
      playBeep(880,0.03,0.12);
      spawnParticles(leftRect.x+leftRect.w, state.ball.y, getComputedStyle(document.body).getPropertyValue('--accent'));
    }
    if(rectCircleCollide(rightRect.x, rightRect.y, rightRect.w, rightRect.h, state.ball.x, state.ball.y, state.ball.r)){
      state.ball.x = rightRect.x - state.ball.r - 0.5;
      const rel = (state.ball.y - (rightRect.y + rightRect.h/2)) / (rightRect.h/2);
      const speedNow = Math.hypot(state.ball.vx, state.ball.vy);
      const angle = rel * (Math.PI/3);
      state.ball.vx = -Math.cos(angle) * Math.abs(speedNow);
      state.ball.vy = Math.sin(angle) * Math.abs(speedNow);
      if(state.ball.vx > 0) state.ball.vx = -Math.abs(state.ball.vx);
      playBeep(720,0.03,0.12);
      spawnParticles(rightRect.x, state.ball.y, getComputedStyle(document.body).getPropertyValue('--accent-2'));
    }

    // scoring
    if(state.ball.x - state.ball.r < 0){
      state.rightScore += 1;
      updateScoreUI();
      state.playing = false;
      resetPositions();
      checkAutoSave('right', state.rightScore);
      setTimeout(()=>serve('right'), 550);
      playBeep(300,0.12,0.08);
    } else if(state.ball.x + state.ball.r > W()){
      state.leftScore += 1;
      updateScoreUI();
      state.playing = false;
      resetPositions();
      checkAutoSave('left', state.leftScore);
      setTimeout(()=>serve('left'), 550);
      playBeep(300,0.12,0.08);
    }

    // friction
    state.ball.vx *= 0.999;
    state.ball.vy *= 0.999;

    updateParticles();
    draw();

    requestAnimationFrame(loop);
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ensure canvas pixel ratio
  let lastClientW = null;
  function resizeCanvasIfNeeded(){
    const rect = canvas.getBoundingClientRect();
    if(lastClientW !== rect.width || canvas.width !== Math.floor(rect.width * devicePixelRatio)){
      resizeCanvas();
      lastClientW = rect.width;
      resetPositions();
    }
  }

  function updateScoreUI(){ scoreLeftEl.textContent = state.leftScore; scoreRightEl.textContent = state.rightScore; }

  // initial
  resetPositions();
  updateScoreUI();
  requestAnimationFrame(loop);

  // unlock audio on first interaction
  document.body.addEventListener('pointerdown', function initOnce(){
    try{ ensureAudio(); }catch(e){}
    document.body.removeEventListener('pointerdown', initOnce);
  });

  // Virtual button binding helper
  function bindBtn(btn, key){
    if(!btn) return;
    const setDown = () => state.keys[key] = true;
    const setUp = () => state.keys[key] = false;
    btn.addEventListener('touchstart', e => { setDown(); e.preventDefault(); }, { passive:false });
    btn.addEventListener('touchend', e => { setUp(); e.preventDefault(); }, { passive:false });
    btn.addEventListener('mousedown', e => { setDown(); e.preventDefault(); });
    btn.addEventListener('mouseup', e => { setUp(); e.preventDefault(); });
    btn.addEventListener('mouseleave', setUp);
  }
  bindBtn(leftUp, 'w');
  bindBtn(leftDown, 's');
  bindBtn(rightUp, 'arrowup');
  bindBtn(rightDown, 'arrowdown');

  // Fullscreen
  fullscreenBtn && fullscreenBtn.addEventListener('click', async () => {
    try {
      if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
      else await document.exitFullscreen();
    } catch(e){ console.warn('fullscreen failed', e); }
  });

  // Leaderboard render already declared earlier - re-use renderLeaderboard
  function loadLeaderboard(){ try{ return JSON.parse(localStorage.getItem(KEY_LEADER) || '[]'); }catch(e){ return []; } }
  function saveLeaderboardArr(arr){ localStorage.setItem(KEY_LEADER, JSON.stringify(arr.slice(0,20))); renderLeaderboard(); }
  function renderLeaderboard(){ const arr = loadLeaderboard(); leaderboardEl.innerHTML = ''; if(arr.length===0){ leaderboardEl.innerHTML='<div class="muted">Еще нет рекордов — будь первым!</div>'; return; } arr.slice(0,20).forEach((it, idx)=>{ const row=document.createElement('div'); row.className='lb-row'; row.innerHTML = `<div class="lb-rank">${idx+1}</div><div class="lb-name">${escapeHtml(it.name||'Аноним')}</div><div class="lb-meta">${it.score} • ${escapeHtml(it.diff)} • ${escapeHtml(it.mode)} • ${new Date(it.date).toLocaleDateString()}</div>`; leaderboardEl.appendChild(row); }); }
  renderLeaderboard();

  // Ensure UI text for particles toggle matches state
  particlesToggle.textContent = state.particlesEnabled ? 'Частицы: Вкл' : 'Частицы: Выкл';

  // expose for debug
  window.pong = { state, serve };

  // init UI from storage
  function initUIFromStorage(){
    themeSel.value = localStorage.getItem(KEY_THEME) || themeSel.value;
    difficultySel.value = localStorage.getItem(KEY_DIFF) || difficultySel.value;
    modeSel.value = localStorage.getItem(KEY_MODE) || modeSel.value;
    volumeRange.value = localStorage.getItem(KEY_VOLUME) ?? volumeRange.value;
    state.volume = parseFloat(volumeRange.value);
    particlesToggle.textContent = state.particlesEnabled ? 'Частицы: Вкл' : 'Частицы: Выкл';
  }
  initUIFromStorage();

})();
</script>
</body>
</html>
